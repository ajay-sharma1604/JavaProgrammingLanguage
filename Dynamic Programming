                                                        Fibonacci - Memoization and Tabulation


public class Basics {

            //Memoization- O(n)

    public static int fibMemoization(int dp[], int n) {
        // base case
        if (n == 0 || n == 1) {
            return n;
        }
        if (dp[n] != 0) {
            return dp[n];
        }
        dp[n] = fibMemoization(dp, n - 1) + fibMemoization(dp, n - 2);
        return dp[n];
    }

            //Tabulation - O(n)
    public static int fibTabulation(int n) {
        int dp[] = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 5;
        int dp[] = new int[n + 1];
        System.out.println(fibMemoization(dp, n));
        System.out.println(fibTabulation(n));
    }
}

Output- 5

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                          Climbing Stairs ( Recursion , Memoization , Tabulation )

import java.util.Arrays;

public class Basics {

    // Recursion- O(2^n)

    public static int climbingStairs(int n) {
        // basecase
        if (n < 0) {
            return 0;
        }
        if (n == 0) {
            return 1;
        }
        // recursion
        return climbingStairs(n - 1) + climbingStairs(n - 2);
    }

    // Memoization -O(n)

    public static int climbingStairs2(int n, int ways[]) {
        // basecase
        if (n < 0) {
            return 0;
        }
        if (n == 0) {
            return 1;
        }

        // recursion + Storage
        if (ways[n] != -1) {
            return ways[n];
        }
        ways[n] = climbingStairs2(n - 1, ways) + climbingStairs2(n - 2, ways);
        return ways[n];
    }

    // Tabulation- O(n)

    public static int climbingStairs3(int n) {
        int dp[] = new int[n + 1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            if (i == 1) {
                dp[i] = dp[i - 1] + 0;
            } else {
                dp[i] = dp[i - 1] + dp[i - 2];
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 5;

        // recursion
        // System.out.println(climbingStairs(n));

        // memoization
        int ways[] = new int[n + 1];
        Arrays.fill(ways, -1);
        // System.out.println(climbingStairs2(n, ways));

        // Tabulation
        // System.out.println(climbingStairs3(n));

    }
}

Output:- 8
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

                             *********************    0-1 Knapsack ( recursion ) ***************************

public class Basics {

    public static int knapsack(int val[], int wt[], int W, int n) { // n-item no
        // Basecase
        if (W == 0 || n == 0) {
            return 0;
        }

        // Recursion

        // case1:- Valid Condition
        if (wt[n - 1] <= W) { // n-1 =last index

            // include
            int ans1 = val[n - 1] + knapsack(val, wt, W - wt[n - 1], n - 1);

            // exclude
            int ans2 = knapsack(val, wt, W, n - 1);

            return Math.max(ans1, ans2);
        }

        // case2:- Invalid Condition
        else {

            //exclude
            return knapsack(val, wt, W, n - 1);
        }
    }

    public static void main(String[] args) {
        int val[] = { 15, 14, 10, 45, 30 };
        int wt[] = { 2, 5, 1, 3, 4 };
        int W = 7; // capacity
        System.out.println(knapsack(val, wt, W, val.length));
    }
}


                        *********************    0-1 Knapsack ( Memoization ) *************************** O(n*W)

public class Basics {

    public static int knapsack(int val[], int wt[], int W, int n, int dp[][]) { // n-item no
        // Basecase
        if (W == 0 || n == 0) {
            return 0;
        }

        if (dp[n][W] != -1) {
            return dp[n][W];
        }

        // Recursion

        // case1:- Valid Condition
        if (wt[n - 1] <= W) { // n-1 =last index

            // include
            int ans1 = val[n - 1] + knapsack(val, wt, W - wt[n - 1], n - 1, dp);

            // exclude
            int ans2 = knapsack(val, wt, W, n - 1, dp);

            dp[n][W] = Math.max(ans1, ans2);
            return dp[n][W];
        }

        // case2:- Invalid Condition
        else {

            // exclude
            dp[n][W] = knapsack(val, wt, W, n - 1, dp);
            return dp[n][W];
        }
    }

    public static void main(String[] args) {
        int val[] = { 15, 14, 10, 45, 30 };
        int wt[] = { 2, 5, 1, 3, 4 };
        int W = 7; // capacity
        int dp[][] = new int[val.length+1][W + 1];

        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                dp[i][j] = -1;
            }
        }
        System.out.println(knapsack(val, wt, W, val.length, dp));
    }
}


                                  
                       *********************    0-1 Knapsack ( Tabulation ) *************************** O(n*W)

public class Basics {

    public static void print(int dp[][]) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static int knapsackTab(int val[], int wt[], int W) {
        int n = val.length;
        int dp[][] = new int[n + 1][W + 1];
        for (int i = 0; i < dp.length; i++) { // 0th col all row =0
            dp[i][0] = 0;
        }
        for (int j = 0; j < dp[0].length; j++) { // 0th row all col =0
            dp[0][j] = 0;
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < W + 1; j++) {
                int v = val[i - 1]; // ith item value    
                int w = wt[i - 1]; // ith item weight

                if (w <= j) {
                    int incProfit = v + dp[i - 1][j - w];
                    int excProfit = dp[i - 1][j];
                    dp[i][j] = Math.max(incProfit, excProfit);
                } else {
                    int excProfit = dp[i - 1][j];
                    dp[i][j] = excProfit;
                }
            }
        }
        print(dp);
        return dp[n][W];
    }

    public static void main(String[] args) {
        int val[] = { 15, 14, 10, 45, 30 };
        int wt[] = { 2, 5, 1, 3, 4 };
        int W = 7;
        System.out.println(knapsackTab(val, wt, W));
    }
}

Output:-
0 0 0 0 0 0 0 0 
0 0 15 15 15 15 15 15
0 0 15 15 15 15 15 29
0 10 15 25 25 25 25 29
0 10 15 45 55 60 70 70
0 10 15 45 55 60 70 75
75

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                      TargetSumSubset O(n*sum)

public class Basics {

    public static void print(boolean dp[][]) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static boolean targetSumSubset(int arr[], int sum) {
        int n = arr.length;
        boolean dp[][] = new boolean[n + 1][sum + 1];
        // i-items j-target sum
        for (int i = 0; i < n + 1; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < sum + 1; j++) {
                int v = arr[i - 1];
                // include
                if (v <= j && dp[i - 1][j - v] == true) {
                    dp[i][j] = true;
                }
                // exclude
                if (dp[i - 1][j] == true) {
                    dp[i][j] = true;
                }
            }
        }
        print(dp);
        return dp[n][sum];
    }

    public static void main(String[] args) {
        int arr[] = { 4, 2, 7, 1, 3 };
        int sum = 10;
        System.out.println(targetSumSubset(arr, sum));
    }
}

Output:-
true false false false false false false false false false false 
true false false false true false false false false false false
true false true false true false true false false false false
true false true false true false true true false true false
true true true true true true true true true true true
true true true true true true true true true true true
true

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                    Unbounded Knapsack O(n*W)

public class Basics {

    public static void print(int dp[][]) {
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static int unboundedKnapsack(int val[], int wt[], int W) {
        int n = val.length;
        int dp[][] = new int[n + 1][W + 1];
        for (int i = 0; i < dp.length; i++) { // 0th col all row =0
            dp[i][0] = 0;
        }
        for (int j = 0; j < dp[0].length; j++) { // 0th row all col =0
            dp[0][j] = 0;
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < W + 1; j++) {
                if (wt[i-1] <= j) { //valid
                  dp[i][j] =Math.max(val[i-1] + dp[i][j-wt[i-1]], dp[i-1][j]);
                } else {//invalid
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        print(dp);
        return dp[n][W];
    }

    public static void main(String[] args) {
        int val[] = { 15, 14, 10, 45, 30 };
        int wt[] = { 2, 5, 1, 3, 4 };
        int W = 7;
        System.out.println(unboundedKnapsack(val, wt, W));
    }
}

Output:-
0 0 0 0 0 0 0 0 
0 0 15 15 30 30 45 45
0 0 15 15 30 30 45 45
0 10 20 30 40 50 60 70
0 10 20 45 55 65 90 100
0 10 20 45 55 65 90 100

100
